import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import bcrypt from "bcryptjs";
import { getUser } from "@/lib/auth";
import { sendWelcomeEmail } from "@/lib/email";

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const search = searchParams.get("search") || "";
    const status = searchParams.get("status") || "";
    const payment = searchParams.get("payment") || "";

    const where: Record<string, unknown> = {};
    
    if (search) {
      where.OR = [
        { name: { contains: search } },
        { email: { contains: search } },
        { phone: { contains: search } },
      ];
    }
    if (status) where.status = status;
    if (payment) where.paymentStatus = payment;

    const clients = await prisma.client.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        trainingPlans: {
          where: { isActive: true },
          include: { trainingPlan: { select: { name: true } } },
        },
        nutritionPlans: {
          where: { isActive: true },
          include: { nutritionPlan: { select: { name: true } } },
        },
      },
    });

    return NextResponse.json(clients);
  } catch {
    return NextResponse.json({ error: "Erro ao buscar clientes" }, { status: 500 });
  }
}

function generatePassword(length = 10): string {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789";
  let pass = "";
  for (let i = 0; i < length; i++) {
    pass += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return pass;
}

export async function POST(request: NextRequest) {
  try {
    const data = await request.json();
    const user = await getUser();

    // Password: use provided, or generate one
    let plainPassword = data.password || "";
    const autoGenerated = !plainPassword;
    if (!plainPassword) {
      plainPassword = generatePassword();
    } else if (plainPassword.length < 6) {
      return NextResponse.json({ error: "Palavra-passe deve ter pelo menos 6 caracteres" }, { status: 400 });
    }

    const hashedPassword = await bcrypt.hash(plainPassword, 12);

    // Create client with full anamnesis
    const client = await prisma.client.create({
      data: {
        name: data.name,
        email: data.email,
        password: hashedPassword,
        phone: data.phone || null,
        dateOfBirth: data.dateOfBirth ? new Date(data.dateOfBirth) : null,
        gender: data.gender || null,
        status: data.status || "active",
        height: data.height ? parseFloat(data.height) : null,
        weight: data.weight ? parseFloat(data.weight) : null,
        bodyFat: data.bodyFat ? parseFloat(data.bodyFat) : null,
        // Medical
        medicalConditions: data.medicalConditions || null,
        medications: data.medications || null,
        allergies: data.allergies || null,
        injuries: data.injuries || null,
        surgeries: data.surgeries || null,
        familyHistory: data.familyHistory || null,
        bloodPressure: data.bloodPressure || null,
        heartRate: data.heartRate ? parseInt(data.heartRate) : null,
        // Lifestyle
        occupation: data.occupation || null,
        sleepHours: data.sleepHours ? parseFloat(data.sleepHours) : null,
        stressLevel: data.stressLevel ? parseInt(data.stressLevel) : null,
        smokingStatus: data.smokingStatus || null,
        alcoholConsumption: data.alcoholConsumption || null,
        activityLevel: data.activityLevel || null,
        // Sports
        trainingExperience: data.trainingExperience || null,
        trainingFrequency: data.trainingFrequency ? parseInt(data.trainingFrequency) : null,
        preferredTraining: data.preferredTraining || null,
        sportHistory: data.sportHistory || null,
        // Goals
        primaryGoal: data.primaryGoal || null,
        secondaryGoal: data.secondaryGoal || null,
        targetWeight: data.targetWeight ? parseFloat(data.targetWeight) : null,
        motivation: data.motivation || null,
        // Nutrition
        dietaryRestrictions: data.dietaryRestrictions || null,
        foodAllergies: data.foodAllergies || null,
        mealsPerDay: data.mealsPerDay ? parseInt(data.mealsPerDay) : null,
        waterIntake: data.waterIntake ? parseFloat(data.waterIntake) : null,
        supplementsUsed: data.supplementsUsed || null,
        notes: data.notes || null,
        plan: data.plan || null,
        paymentStatus: data.paymentStatus || "pending",
        managerId: user?.id || null,
      },
    });

    // Create User record so the athlete can log in
    await prisma.user.create({
      data: {
        name: data.name,
        email: data.email,
        password: hashedPassword,
        role: "client",
      },
    });

    // Create initial body assessment if weight provided
    if (data.weight) {
      await prisma.bodyAssessment.create({
        data: {
          clientId: client.id,
          weight: parseFloat(data.weight),
          bodyFat: data.bodyFat ? parseFloat(data.bodyFat) : undefined,
        },
      });
    }

    // Send welcome email (non-blocking)
    try {
      const trainer = user ? await prisma.user.findUnique({ where: { id: user.id } }) : null;
      await sendWelcomeEmail({
        to: data.email,
        athleteName: data.name,
        trainerName: trainer?.name || "O teu treinador",
      });
    } catch { /* email failure is not critical */ }

    return NextResponse.json({
      ...client,
      generatedPassword: autoGenerated ? plainPassword : undefined,
    }, { status: 201 });
  } catch (error: unknown) {
    const msg = error instanceof Error ? error.message : "Erro ao criar cliente";
    if (msg.includes("Unique constraint")) {
      return NextResponse.json({ error: "Email jÃ¡ registado" }, { status: 400 });
    }
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}
